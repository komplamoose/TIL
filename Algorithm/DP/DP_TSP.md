# 알고리즘 : Dynamic Programming

---

## 외판원 순회 문제

> 모든 도시를 한번씩만 방문하여 자기 자신의 도시로 돌아오는 데, 도시로 가는 Edge엔 Weight가 부여되어 있다.

이 때, 자기 자신으로 돌아오는 경우 중, 통과하는 엣지 가중치의 합이 최소가 되는 경우를 구하라.
> 

<br><br>

### 문제 설명

- `Weighted`, `Directed Graph` 기준이다.
- 최소한 하나의 `해밀턴 회로`가 존재한다고 했을 때, 이 회로들 중 `최소 값`을 가지는 회로룰 구하라.
- 회로의 경우 `어디서 출발`하는지는 `상관이 없다`는 것을 우리는 해밀턴 회로를 공부하면서 배웠다.
- `브루트포스`하게 접근하기
    - 모든 `해밀턴 회로` 다 구해버린 다음. 여기서 `가중치 가장 낮은 회로`를 구하자.
        - `(n-1)!`
<br><br>

### 접근법 : DP

- `비트마스킹`을 통해 도시의 방문여부 부분집합을 효과적으로 표현할 수 있다.
- 도시들을 `집합`으로 표현하였을 때, 도시가 `4개`가 있다면 그 부분집합은
    - `방문하는 경우` - `안 방문하는 경우` (0-1)로
        - `4bit`로 표현할 수 있을 것이다.
- 그렇기 때문에, `n개의 원소(도시)`의 방문 여부 부분집합을 구하기 위해선 `n-digit`가 필요함을 우리는 생각해낼 수 있다.
- 이때, 도시가 만약 `3개`가 존재한다면
    - 모든 도시를 방문하는 경우는 `111`로 표현 가능하고, 이걸 이진수로 변환하면 ⇒ `7 (2^3 -1)`
    - 하나도 방문 안하는 경우는 `000`, ⇒ `0 (2^0 -1)`
- 각 비트마다 표현하는 숫자가 다르기 때문에, 우리는 `10진수`를 `n진수` 변환하는 과정으로 현재 부분집합의 형태를 알 수 있게 된다.
- 출발 노드 `V1`은 고려 안해도 된다. 우리는 오로지 `V2`에서 `Vn`까지의 도시들의 부분집합만을 고려하면 된다.
<br><br>

### DP 구조 만들기

- DP 계산을 하기위해 **메모이제이션 배열** `D`를 생성한다.
- 이때 `D`는
    - `D[vi][a]`
        - `버텍스 vi`에서, `A 집합`에 있는 버텍스들을 한번만 거쳐서 다시 `1번 버텍스`로 돌아가는 데 걸리는 **최소 비용**
    - `D[vi][0]`
        - `버텍스 vi`에서 **중간에 아무 버텍스도 거치지 않고** `1번 버텍스`로 가는 비용
        - 즉, `Vi`에서 `V1`로 가는 비용
- 또한 `D[vi][A]`는
    - `D[vi][a]= minimum(W[i][j]+D[vi][A-{vj}])`
        - 이 때, `j`는 집합 `A`에 존재하는 원소여야 하며, 집합 `A`의 모든 원소를 순회함
        - `버텍스 i`에서 `A` 안에 존재하는 버텍스 중 하나인 `j`로 가는 비용 + `버텍스 i`에서 `A`에서 `j 버텍스` **없었을 때**의 최소비용
            - 여기서 **가장 낮은 값**이 된다.
- 이 때, 집합 `A`에서 **이 버텍스가 있는지**, 혹은 이 버텍스를 **제외하는 지**, 현재 **몇 개의 버텍스를 방문하였는지**는 비트시프트를 통해 확인-구현할 수 있다.

<br><br>

### 구현

- 필요 함수 1 : `Count` 함수
    - 집합 `A`를 오른쪽으로 비트시프트하면서, `1`과 `and` 관계인 녀석이 몇 개나 있는지 체크한다.
    - 집합 A에서, `방문한 버텍스`가 총 몇 개인지 체크하는 함수다.
- 필요 함수 2 : `isIn` 함수
    - `1`을 `i-2` 만큼 레프트 시프트 시킨 인덱스와 `and` 관계인 경우, 현재 부분집합이 `i번째 도시를 방문했다`는 뜻이다.
- 필요 함수 3 : diff 함수
    - `1`을 `i-2` 만큼 레프트 시킨 인덱스를 `false`로 바꾼 부분집합을 리턴하는 함수다.
    - 부분집합에서 `특정 버텍스 i`를 **제외한 부분집합**을 찾고 싶을 때 사용한다.

<br><br>

### 전체 코드

> 🤨 매우 어렵기 때문에 주석 많이 달아놨다.
> 

```cpp
#include <iostream>
#include <vector>
#include <cmath>
#define INF 10000001

using namespace std;

int W[100][100]; // 그래프 행렬
int D[100][100]; // DP 행렬
int P[100][100]; // 경로 찾기용 배열

int v, e; // 총 버텍스, 엣지 갯수

bool isIn(int i, int A) {
    return (A & (1 << (i - 2))) != 0; // i-2만큼 시프트시켜서 있는지 체크 (A집합엔 2번째 버텍스부터 체크되므로, 0번째 칸에 1이면 2번째 버텍스에 방문했다는 뜻)
} // 주의 ! : 있으면 true 리턴함.

int diff(int A, int j) {
    return (A & ~(1 << (j - 2))); // A에서 j번쨰 버텍스 지워버린 부분집합을 리턴해줌. 
    //j는 최소 2이고, 부분집합은 출발을 고려하지 않은 2번째 버텍스부터 체크하기로 하였으므로, j가 2일 경우 j-2=0, 첫번째 비트를 체크하는 것이 맞음
}

int count(int A) {
    int cnt = 0;
    for (; A != 0; A >>= 1) // 1이 몇개 있는지 (총 몇개의 버텍스를 방문했는지 체크)
        if (A & 1) cnt++;
    return cnt;
}

int minimum(int n, int i, int& minJ, int A, int W[][100], int D[][100])
{
    int minV = INF, value;
    for (int j=2; j<=n ;j++) { // 모든 버텍스 순회하지만, 버텍스 j는 A 부분집합에 존재해야 한다.
        if (!isIn(j, A)) continue; // j번째 버텍스가 A에 없다면 탈락. 우리는 집합 A에 존재하는 j번째 버텍스의 경우만 탐색한다.
        value = W[i][j] + D[j][diff(A,j)]; // i번째 버텍스에서 j번째 버텍스로 직통으로 이동한 값 + j번째 버텍스에서 시작하여 A에서 j뺀 부분집합에서 첫번째로 돌아가는 최소 비용의 최소를 구하자.
        if (minV > value){ 
            minV=value;
            minJ = j; // 이때 구해낸 버텍스 i에서 이동하였을 때의 최소비용을 만들 수 있는 버텍스 j의 번호를 저장한다.
        }
    }

    return minV; // 최소비용 리턴
}

void tour(int v, int A, int P[][100]) {
    int k= P[v][A]; // v번째 버택스에서 A 부분집합에 있는 도시들을 통과하여 다시 첫번째로 돌아오는 최단 경로에서, 다음으로 가야할 버텍스 넘버

    if (A==0){ // 더 이상 사이에 지나갈 버텍스가 없는 경우 => 자기 자신으로 돌아옴 1번! 
        cout << "1";
    }
    else {
        cout << k << " "; // v번에서 이제 k번 버텍스로 이동해야 한다.
        tour(k, diff(A,k), P); //이제 k번 버텍스에서 출발하여, 기존 부분집합 A에서 K를 제외한 버텍스들을 통과하여 출발로 돌아가기 위해 K가 가야하는 다음 버텍스를 또 추적한다.  
    }
}

void travel(int n, int W[][100], int D[][100], int P[][100], int& minlength)
{
    int i, j, k, A;

    int subset_size = pow(2, n-1); // 부분집합의 최대 갯수 => 2^(n-1), n-1인 이유 : 첫 번째 출발 버텍스는 생각하지 않기로 했으니까
    for (i=2; i<=n; i++) // i번째 버텍스에서 첫번째 버텍스로 돌아가는 비용 초기화
        D[i][0] = W[i][1];
    for (int k=1; k<=n-2; k++) { // 중간에 버텍스 1개만 골라서 첫번째로 돌아가는 경우에서부터, n-2개의 버텍스를 방문하였을때 첫번째로 돌아가는 경우까지 순회. n-1개의 버텍스 다 방문해서 찾는 경우는 곧 종결이라는 뜻이므로, 마지막에 구할거임
        for (A=0; A<subset_size; A++) { // 모든 도시부터 나올 수 있는 모든 경우의 수 탐색
            if (count(A) != k) continue; // 만약 부분집합의 도시가 K개가 아니라면, 스킵한다. 우리는 총 k개의 도시만 방문하여 첫번째로 돌아가는 케이스를 찾고 싶다.
            for (i=2; i<=n; i++) { // 2번 버텍스부터 마지막 버텍스까지 순회하면서, i번째 버텍스에서 출발하여 A 부분집합 내부에 있는 버텍스만 방문하여 다시 출발 버텍스인 첫 번째 버텍스까지 돌아오는 최소비용을 계산하고 싶다.
                if (isIn(i, A)) continue; // 만약 부분집합에 i번째 버텍스가 이미 존재한다면 => 중복 방문이라는 뜻이므로 탈락
                D[i][A]= minimum(n, i, j, A, W, D); // 버텍스의 총 갯수, 출발하려는 i번째 버텍스, i번째 버텍스에서 다음으로 넘어가는 버텍스를 찾기위한 j, 부분집합 A
                P[i][A]= j; // 버텍스 i에서, A 부분집합만을 통과하여 출발 버텍스로 돌아오려는 과정에서, i번째 버텍스는 j번 버텍스로 이동한다.
            }
        }
    }
    A=subset_size -1; // 모든 버텍스를 방문하였을 때의 경우는 2^n -1이 된다. (모든 버텍스가 11111111 형태인 경우)
    D[1][A] = minimum(n, 1, j, A, W, D); // 첫번째 버텍스에서 출발하였을 때, 모든 버텍스를 통과하여 다시 첫번째로 돌아오는 경우의 최단거리 구하기
    P[1][A] = j; // 첫번째 버텍스는 그 다음으로 j번 버텍스로 이동한다. 
    minlength = D[1][A]; // 최단거리 저장
}

int main()
{
    int minlength;
    cin >> v >> e; // 버텍스-엣지 갯수 입력받음

    for (int i=0; i<e; i++) { // 그래프 생성, Directed 그래프임
        int x, y, w;
        cin >> x >> y >> w;
        W[x][y]=w;
    }

    for (int i=1; i<=v; i++) { // 갈 수 있는 버텍스가 없는 경우 INF, 자기 자신의 경우 0으로 초기화
        for (int j=1; j<=v; j++) {
            if (i==j) continue;
            if (W[i][j]==0) W[i][j]=INF;
        }
    }

    travel(v, W, D, P, minlength); // 총 버텍스의 갯수, 그래프, DP 배열, 경로 탐색을 위한 P배열, 최소길이 값을 저장할 minlength를 파라미터로 넘겨줌

    cout << minlength << endl << "1 ";
    tour(1, pow(2, v-1)-1, P); // 1번 버텍스에서, 1번 버텍스를 제외한 버텍스들을 통과하려는 데, 다음 버텍스로 어디를 가야할 지 찾자.
    cout << endl;

    for (int i=1; i<=v; i++) {
        for (int j=0; j<pow(2, v-1); j++) {
            if (D[i][j]==INF||D[i][j]==0) continue; 
            cout << i << " " << j << " " <<  D[i][j] << endl;
        }
    }
}
```

---
