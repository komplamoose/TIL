# 알고리즘 : DP

---

## 0-1 배낭 문제

> 무게-가치가 있는 아이템들이 N개 있을 때, 용량 M인 가방이 있다면 이 가방에 최대로 담아낼 수 있는 Optimal한 가치 합을 구하라.

단, 물건은 분할 불가능하다. 물건을 담거나-안 담거나 (0-1) 두 조건만 존재한다.
> 

<br>

### 문제 설명

- 부분집합의 합 문제로 환원 가능하다
    - 물건을 넣냐-안넣냐 (부분집합에 넣냐 안넣냐)
- 그냥 브루트포스로 풀면 2^n이 나온다.

### 접근 방법 1 (Naive-DP)

- 아이템이 N개 존재하고, 가방 총 용량이 W라고 하자.
- 총 무게가 w이고, i개의 아이템에서만 골라서 가방에 담는다고 가정하자.
- 이 때 총 담는 무게 합은 w를 초과할 수 없다는 조건 하에서의 최적 이익이 `P[i][w]`라면, 이 `P[i][w]`는 2가지 조건으로 나뉜다.
    - Case 1 : `P[i][w] = max(P[i-1][w], pi+P[i-1][w-wi])`
        - `wi`가 `w`보다 작거나 같을 경우
        - `i번째 아이템 그냥 안 넣는 경우`와, `현재 무게에서 i번째 아이템이 들어갈 자리`를 남기고, `i번째 아이템을 안 넣었을 때의 최대 가치`에, `i번째 아이템 넣는 경우를 더한 값`을 비교해 더 큰 값을 상속 받는다.
        - `pi` ⇒ i번째 아이템의 가치
        - `wi` ⇒ i번째 아이템의 무게
    - Case 2 : `P[i][w]= P[i-1][w]`
        - `wi`가 `w`보다 클 경우
        - i번째 아이템은 무조건 못 넣으니까, i번째 아이템 안넣고 계산한 동일 용량 최대 가치를 그대로 상속받는다.
    - 이 때, `P[0][w]`와 `P[i][0]`은 0이 된다.
        - 아이템을 하나도 안 넣거나, 가방에 담을 수 있는 용량이 없는 경우이므로 당연하다.
    - 이렇게 Bottom-Up 식으로 계산하였을 때, `최대 아이템 i`, `최대 용량 w`라면 `P[i][w]`에 있는 값이 바로 우리가 찾는 `i개의 아이템을 w 용량 가방에 담을 때의 최대 가치`가 된다.

> 주의 ! ⚡
> 
- 이 방법으로 해결할 시 시간 복잡도가 `O(nw)`가 나온다.
    - **다항시간 알고리즘 아니다**
    - 만약 아이템의 갯수가 `2^n`개라면 지수시간 복잡도를 가진다.
    - `w`와 `n`은 관계가 없기 때문에, `w`가 매우 커지면 시간 복잡도가 `n`과 관계 없이 커질 수 있다.
    - 이때 `n`이 아이템의 갯수고, `w`는 가방의 최대 용량이다.
    - 브루트 포스로 풀면 그냥 `2^n`이 나오는 데, 이 방법의 경우 `Worst Case` 보장이 되지 않는다.

<br>

### 접근 방법 2 (Top-Down으로 개선!)

- 🔥 **최악의 경우가 `세타(2^n)`이 보장되도록 개선할 수 있다.**
- 기존 방법의 경우, 필요 없는 사이 값들도 다 계산해야 한다.
- 최종 구하고자 하는 결과 `P[n][w]`에서 시작하자.
- 이때 `P[n][w]`는 2가지로 분리될 수 있다.
    1. `P[n][w] = max(P[n-1][W], pn + P[n-1][W-wn])`
        1. n번째 아이템을 넣을 수 있는 경우 (최대 용량보단 작기 때문에 우겨넣기 가능)
        2. 넣는 경우
        3. 안넣는 경우
        4. 이 두 가지 경우의 수 중에서 큰 값을 넣는다.
    2. `P[n][w] = P[n-1][w]` 
        1. N번째 아이템의 크기가 가방 용량을 초과해서 무조건 못넣는 경우
- 결론적으로, `P[n][w]`를 계산하기 위해선 P 배열에서
    - `P[n-1][W]`
    - `P[n-1][W-Wn]`
    - 딱 이 2개만 필요하다는 것이 밝혀진다. 나머지 값들은 계산할 필요가 없다 !
- 일반화하자 !
    - `P[i][w]를 계산하는 데엔 P[i-1][w]와 P[i-1][W-wn]을 가지고 계산한다.`
    - 이렇게 탑-다운 방식으로 내려가면서, 만약 n=1이거나, W≤0에 도달하면 Return한다.
- 사전에 필요한 엔트리만 계산하기로 합의하였으므로, 최악의 경우를 `O(minimum(2^n, nW))`으로 고정할 수 있게 된다.
- 이 알고리즘을 사용하는 경우, `P`의 필요 없는 값들을 저장-계산할 필요가 사라지기 때문에, `배열`을 사용하지 않아도 된다. `Map`을 통해 필요 정보만 추출하는 것이 더 낫다.
    - 이 경우 공간복잡도 또한 기존의 `O(nW)`에서 `O(minimum(2^n, nW))`가 된다.

<br>

### 전체 코드 (Top-Down)

```cpp
#include <iostream>
#include <map>
#include <vector>
#include <algorithm>

using namespace std;

map<pair<int,int>, int> d; // 메모이제이션을 위한 Map 선언

int v[100001]; // 물건 가치
int w[100001]; // 물건 무게

int nn, kk; // 총 물건의 갯수, 가방 용량

int solve(int n, int k) // Top인 N, W부터 시작
{
    if (n==0 || k<=0) { // 가장 바닥에 도달했다면 0 리턴
        return 0;
    }
    int lvalue, rvalue;
    if (d.find(make_pair(n-1,k))!=d.end()) // 만약 d[n-1][k]값이 현재 존재한다면 집어넣기
        lvalue = d[make_pair(n-1,k)];
    else
        lvalue = solve(n-1, k); // 존재 안한다면 d[n-1][k] 값 구하러 출발
    if (d.find(make_pair(n-1,k-w[n]))!=d.end()) // 있으면 집어넣기
        rvalue=d[make_pair(n-1,k)];
    else
        rvalue=solve(n-1, k-w[n]); // 없으면 구하러 출발
    if (w[n] > k) // 만약 n번째 물건이 가방 용량보다 커서, 아예 넣을 수가 없는 경우
        d[make_pair(n,k)]=lvalue; // 아까 구했던 d[n-1][k] 값을 상속받는다. (n번째 아이템 안넣는 경우의 최대 이득)
    else
        d[make_pair(n,k)]=max(lvalue, v[n]+rvalue); // n번째 아이템을 넣을 수 있는 경우, n번째 아이템 넣을때의 최대 이득, 혹은 n번째 아이템 안넣을 때의 최대 용량 중 더 큰 값을 상속받는다. 
        // 가장 Bottom의 경우, v[n]의 가치를 받아서 올라간다고 보면 된다. 

    
    return d[make_pair(n,k)]; // 최종적으로 구한 값을 리턴해준다. 
}

int main()
{
    cin >> nn;
    
    for (int i=1; i<=nn; i++) {
        cin >> w[i];
    }
    for (int i=1; i<=nn; i++) {
        cin >> v[i];
    }

    // 단위무게로 정렬 START
    // vector<pair<int,pair<int,int>>> temp; 
    // for (int i=1; i<=nn; i++) {
    //     temp.push_back(make_pair(v[i]/w[i],make_pair(w[i],v[i])));
    // }
    // sort(temp.begin(), temp.end(), greater<>());

    // for (int i=0; i<nn; i++) {
    //     w[i+1]=temp[i].second.first;
    //     v[i+1]=temp[i].second.second;
    // }
    // 단위무게로 정렬 END
    // 주의 ! : 이 부분은 알고리즘실습 문제 출력 조건을 충족하기 위해 추가한 것임. 정렬 안해도 정상 동작할 것임.

    for (int i=0; i<=nn; i++) { // d[n][0] => 0 초기화
        d[make_pair(i,0)]=0;
    }

    int tk;
    cin >> tk;
    while (tk--) {
        d.clear(); // 매 테스트케이스마다 d 맵을 초기화해줘야 함.
        cin >> kk;
        for (int i=0; i<=kk; i++) { // d[0][w] = 0 초기화
            d[make_pair(0,i)]=0;
        }
        int answer = solve(nn,kk); // 얻어낸 d[nn][kk] 값 반환

        cout << d[make_pair(nn,kk)] << "\n";

        for (int i=1; i<=nn; i++) { // 문제 특수 출력조건 처리용
            for (int j=1; j<=kk ; j++) {
                if (d.find(make_pair(i,j))!=d.end()) cout << i << " " << j << " " << d[make_pair(i,j)] << "\n";
            }
        }
    }
}
```

---
