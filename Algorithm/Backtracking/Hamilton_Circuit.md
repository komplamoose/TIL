# 알고리즘 : Backtracking

---

## 해밀턴 회로 (경로)

> 그래프가 주어졌을 때, 모든 버텍스를 단 한번만 방문해서 다시 출발 지점으로 돌아오는 경우를 찾아라 !
> 

<br>

### 문제 설명

- Connected된, Undirected Graph가 주어진다.
    - 오일러 회로 : 모든 `간선` 을 한번씩만 방문해서 원래 자리로 돌아올 수 있는가?
    - 해밀턴 회로 : 모든 `정점` 을 한번씩만 방문해서 원래 자리로 돌아올 수 있는가?
        - 돌아오지 않아도 되는 경우 ⇒ 경로
        - 돌아와야 하는 경우 ⇒ 회로
- 브루트 포스하게 접근할 경우 `O(n!)` 의 시간복잡도가 든다.
- 그래프에 해밀턴 회로가 존재하는지 , 안하는지를 수학적으로 결정할 수 없다.

<br>

### 상태공간 트리 설정

- 임의의 출발 정점에서 시작
- 출발 정점에서 인접한 다른 정점 방문하는 경우로 가지를 내린다.
- Depth ⇒ 경로로 선택한 버텍스 갯수

<br>

### 가지치기 조건

1. 경로의 `i번째`로 선택된 정점은 반드시 `i-1 번째`로 선택된 정점과 인접해야 한다.
2. `마지막 정점`(n-1번째 정점)에 도달했을 때, 이 정점은 반드시 `출발 정점`에 인접해야 한다.
3. `i번째`로 선택한 정점은, `이전에 선택했던 정점`과 동일할 수 없다.
    1. **중복 방문 불가**

<br>

### 유망함수 설정

- 조건 1
    - 이번에 선택한 버텍스가 만약 `N-1번째 버텍스(=마지막 버텍스)`라면, 반드시 `첫 번째로 방문한 버텍스`와 **인접**해야 한다.
    - **만약 문제가 회로가 아니고 경로라면, 조건 1은 없어도 된다.**
- 조건 2
    - 버텍스가 만약 `첫 번째 이후로 선택한 버텍스`라면, 바로 `직전에 선택한 버텍스(=i-1번째 버텍스)`와 **인접**해야 한다.
- 조건 3
    - 조건 2를 만족하는 경우에, 만약 `이번에 선택한 버텍스`는 이전에 선택했던 적이 없어야 한다.

<br>

### 전체 코드

```cpp
#include <iostream>

using namespace std;

int cnt=0;
int v, e; // 그래프의 총 버텍스, 엣지 수 

int G[151][151]; // 입력받을 그래프 설정
int visit[151]; // 방문 기록 저장

bool promising(int k) // 유망함수
{
    int j=1;
    if (k==v-1 && !G[visit[v-1]][visit[0]]) // 조건 1 : 만약 마지막에 도달했다면, 첫 번째로 선택한 버텍스와 인접해야 한다.
        return false;
    else if (k > 0 && !G[visit[k-1]][visit[k]]){ // 조건 2 : 첫 번째로 선택한 버텍스가 아니라면, 바로 직전에 선택한 버텍스와 인접해야 한다.
        return false;
    }else{
        while(j<k){ // 인접하다면, 이 버텍스는 이전에 선택된 적이 없어야 한다. 
            if (visit[j]==visit[k]) return false; // 쭉 탐색해서 혹시 이전에 선택된 적 있다면 탈락
            j++;
        }
    }

    return true;
}

void solve(int k)
{
    if (promising(k)) // 유망함수 체크
    {
        if (k==v-1) {
            cnt++; // 유망함수 조건 통과했으니 더 이상 체크 안해도 됨 !
            return;
        }else {
            for (int i=2; i<=v; i++) { // 첫 번째 버텍스는 이미 출발 정점으로 설정했으므로 무조건 갈 필요 없음. 첫 번째 제외한 다른 모든 버텍스 경우의 수 탐색
                visit[k+1]=i; // k+1 번째로 방문한 버텍스가 i번 버텍스라고 가정하고 뿌리 내리기
                solve(k+1);
            }
        }
    }
}

int main()
{
    cin >> v >> e;

    for (int i=0; i<e ; i++) {
        int a, b;
        cin >> a >> b;
        G[a][b] = 1;
        G[b][a] = 1;
    } // 그래프 설정

    visit[0]=1; // 첫 번째 방문 버텍스 => 1번 버텍스로 설정
    solve(0);

    cout << cnt << "\n";
}
```

---
