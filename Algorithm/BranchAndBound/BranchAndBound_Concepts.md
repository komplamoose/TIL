# 알고리즘 : Branch and Bound

---

## 분기 한정법 : 기본 컨셉

> ✅ 우리가 알고리즘을 해결하는데 생각해야 하는 순서
> 
1. 재귀적 접근
2. `분할 정복`적인 접근
3. 분할시 `중복 부분` 문제가 발생하고, `부분 최적 구조`를 가지는지 확인
    1. `다이나믹 프로그래밍`
        1. `메모이제이션` (Top-Down)
        2. `타불레이션` (Bottom-up)
4. `Greedy`한 접근법으로 해결되는지 확인
5. 모두 다 안되면 `브루트포스`하게 접근, `가지치기`하기
    1. `DFS`를 통해 상태공간트리 탐색 ⇒ `백트래킹` 
    2. `BFS (Best-First-Search)` 를 통해 상태공간트리 탐색 ⇒ `분기한정`

<br>
<br>

### 기본 개념

- `백트래킹`의 향상 버전이라고 볼 수 있다.
- `최적화 문제`에 대해서 상태 공간 트리를 탐색해야 하는 경우, `백트래킹`보다 더 효율적으로 가지치기 할 수 있다.
- 만약 `경우의 수를 따지는 문제` (Ex. `N-Queens`, `Sum of Subsets`… etc) 라면 `백트래킹`, `분기한정` 둘 다 비슷하다.
- 그렇지만 `최적화 문제` (Ex. `배낭문제`)를 다룰땐, `분기한정법`을 사용하는 것이 더 효과가 좋을 수 있다.
<br>

### BFS (Breadth First Search, 너비우선 탐색)

- 트리를 레벨별로 방문하는 방법.
- 단순히 `DFS` ⇒ `BFS`로 바꾼다고 해서 성능이 좋아지는 것은 절대 아니다.
- `Best First Search`를 사용하는 것이 성능 향상으로 이끌 수 있다.
<br>

### 분기한정법 접근

- `분기한정`을 하려면, 실제로 상태공간 트리 노드를 제작해야 한다.

```cpp
typedef struct node* node_ptr;
typedef struct node{
		int level;
		int weight;
		int profit;
}node_t;
```

- 이전의 `백트래킹` `0-1 배낭 문제`에서처럼, 매 노드마다 얻어낼 수 있는 최대 값인 `Bound` 값을 계산한다.
- 이때 `Bound` 값을 계산하는 함수를 `Evaluation` 함수, `평가함수`라 한다.
    - 주의 : `promising` 함수와 `evaluation` 함수는 아예 다른 영역임
<br>

### Best First Search

- 내가 방문할 자식노드들 중, `가장 유망한 녀석`을 먼저 방문하는 방법
    - 기존 너비 우선 탐색 방법이 큐를 사용하였다면, 최적 우선 탐색 기법에서는 `Bound` 값을 기준으로 하는 `우선순위 큐`를 사용한다.
- 만약 기대이익 `Bound`보다 현재까지 구한 옵티멀 값이 더 작다면, 노드는 `Promising`하다.
    - 만약 `유망`하다면, `PQ`에 이 노드를 넣어준다.
    - `PQ`에서 `Pop`을 한 뒤, `Pop`한 노드의 자식 노드들의 `Bound` 값을 계산하여 `PQ`에 다 집어넣는다.
    - 한 노드의 모든 자식에 대해 평가 완료하였으니, `PQ`에서 `Pop`되는 노드는 `Bound 값이 가장 큰 노드`일 것이다.
    - 여기서 또 `Pop` 한 뒤, 이 노드가 `유망`한지 체크하고, `유망`하다면 자식들 모두 평가해서 집어넣는 과정을 반복한다.
    - 만약 평가하였는데 `Bound` 값이 `Maxprofit`보다 작거나, 같은 경우 더 이상 내려갈 필요가 없음을 의미하니까 `PQ`에 집어넣지 않는다.
    - `PQ`가 `Empty` 할 때까지 반복한다.
    - 방문했던 노드들 중 가장 큰 `Profit`을 가진 노드가 최적 값을 지닌 노드가 된다.
- 절대적으로 이 방법이 좋다고 할 수는 없지만, 기대 이익이 큰 기준으로 탐색할 경우, 일반적으로 가장 가능성이 높은 노드를 방문하여 최대 이익을 구해놓고 다른 노드들을 가지치기할 수 있기 때문에, 더 효율적일 것이라 예측할 수 있다.
<br>

### 구현하기

- 노드가 `Promising`한지 체크한다
    - 노드의 `bound`가 `Optimal보다 큰지` 체크한다.
- `Promising` 하다면, `PQ`에 넣어준다.
- `PQ`에서 하나 뽑아서 반복한다.
- `PQ` 빌 때까지 반복!

---
