# 자바스크립트 : 변수, 호이스팅, TDZ

---

## 변수

### 변수 복습

우리는 이미 `var`, `let`, `const`에 대해 알고 있다.

`let`, `const`는 ES6부터 추가되었다. 

이전 버전 자바스크립트에선 `var`를 사용한다.

이 셋을 비교해보자.

<br>

### 변수 1. var

- 한번 선언된 변수를 다시 선언할 수 있다.

```jsx
var name = 'mike';
console.log(name);

var name = 'jane';
console.log(name);

// no problem
```

- 선언하기 전에 사용할 수 있다. 

<br>

```jsx
console.log(name); // result : undefined

var name = 'mike';
```

오류가 발생할 것 같지만 그렇지 않다.

왜 그럴까? var는 사용하는 순간 호이스팅된다. 사실상 저 코드는 아래와 같다.

<br>

```jsx
var name;

console.log(name); // result : undefined

name = 'mike';
```

코드가 실제로 끌어올려지진 않지만, 최상위로 끌어올려진 것처럼 동작한다.

이때, 선언은 호이스팅되지만, 할당은 호이스팅되지 않기 때문에, name엔 값이 할당되지 않은 상태로 올라간다. 

같은 상황에서 `let`을 비교해보자.

<br>

```jsx
console.log(name); // result : ReferenceError

let name = 'Mike';
```

`let` 사용시 오류가 발생한다. `let`은 호이스팅되지 않는 걸까?

**아니다. `let`, `const` 모두 호이스팅된다 !**

> 호이스팅
: 스코프 내부 어디서든 변수 선언은 최상위에 선언된 것처럼 행동한다는 뜻.
> 

<br>

근데 왜 동작 안할까? 바로 

`Temporal Dead Zone`, 줄여서 `TDZ` 때문이다.

TDZ 영역 안에 있는 변수들은, 사용할 수 없어진다.

let과 const는 TDZ의 영향을 받는다. 

할당이 되기 전엔 사용할 수 없다. 이는 코드의 잠재적 버그를 막아주는 좋은 기능이다.

<br>

### 호이스팅

아래의 코드를 보자.

<br>

```jsx
let age = 30;

function showAge() {
  console.log(age);

}

showAge();
```

문제 없다.  근데 만약 코드가 이렇게 바뀐다면?

<br>

```jsx
let age = 30; // 변수 1

function showAge() {
  console.log(age);

  let age = 20; // 변수 2
}

showAge();
```

<br>

오류가 발생한다. 

여기서 중요한 점은 `let`도 호이스팅이 일어난다는 점이다.

호이스팅은 Scope 단위로 일어난다.

여기서 `변수 2`의 스코프는 `showAge()` 함수 내부다, 

만약 `let`이 호이스팅되지 않는다면, 더 상위에 있는 `변수 2`을 받아 정상적으로 출력해야 맞을 것이다!

⇒ 결국 `function` 스코프 단위로 `let` 변수의 호이스팅이 발생해, `console.log()` 가 출력하는 `age`는 `변수 2`가 되고, 아직 값이 할당되지 않아 `TDZ`에 존재하기 때문에 오류가 발생하는 것이다.

<br>

### 변수의 생성과정

변수는 총 3단계의 생성 과정을 가진다.

1. **선언 단계**
2. **초기화 단계**
3. **할당 단계**

<br>

- Case 1. `var`

여기서 `var`는 **선언과 초기화가 동시에 일어난다.**

`var`는 선언되자마자 `undefined`가 할당(초기화)된다.

이래서 할당을 안해줬는데도 에러가 아니라 `undefined`를 출력하는 것이다. 

<br>

- Case 2. `let`

`let`은 선언 단계와 초기화 단계가 분리되어 실행된다.

호이스팅 되면서 선언단계가 이뤄지지만, 초기화는 런타임시 실제 코드에 도달했을때 진행되기 때문에, 

호이스팅된 `let`를 호출하면 `ReferenceError`가 발생하는 것이다.

<br>

- Case 3. `const`

`**const` 는 선언+초기화+할당이 동시에 일어난다.** 

어찌보면 당연한 것이, const는 한번 할당된 값이 바뀌면 안된다. 그러므로 생성시 반드시 할당을 해줘야 할 것이다. 나중에 바꿀 수 없으니까. 

그런 이유로 `const`는 `var` 이나 `let` 과 다르게, 선언시 단순 변수 선언은 허락되지 않는다. 

<br>

### 스코프

`var`는 `함수 스코프` 이다. (Function-scoped)

`let`, `const`는 `블록 스코프`다. (Block-scoped)

<br>

- 블록 스코프
    - 모든 코드 블록 내에서 선언된 변수는 해당 코드 블록 내에서만 유효하며, 외부 블록에선 호출 불가능.
    - 블록의 지역변수가 된다는 뜻이다.
    - 여기서 블록은 `함수`, `조건문`, `반복문` 모두 해당된다.

반면 함수 스코프는, 함수 내에서 선언된 변수만 그 지역변수가 되는 것이다.

한가지 예를 들어보자.

<br>

```jsx
const age = 30;

if (age > 19) {
	var txt = '성인';
}

console.log(txt);
```

이때, `txt`는 블록스코프가 아니기 때문에, `if` 블록 바깥에서도 자유롭게 사용할 수 있다.

하지만 `var`도 함수 내부에서 선언된다면, 그 함수 바깥에선 사용할 수 없다.

`var`가 유일하게 벗어날 수 없는 것은 함수 뿐이라고 기억하자. 

<br>
<br>

# 💡 결론

> 결론적으로 let과 const를 사용하는 것이 예측 가능한 프로그래밍을 하는데 유용하다. 

var 쓰지마라.
>
